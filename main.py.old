from dataclasses import dataclass
from typing import Self, Callable
import re

@dataclass
class ParserStatus:
    isFailure: bool
    originalData: str
    offset: int
    payload: dict

    @classmethod
    def copy(cls, other: Self, **overwrites: dict):
        fields = other.__dict__
        for key, value in overwrites.items(): fields[key] = value
        return cls(**fields)


type ParserFunc = Callable[[ParserStatus], ParserStatus]

def integer(p: ParserStatus) -> ParserStatus:
    result = re.compile(r'\d+').match(p.originalData, p.offset)
    if result:
        start, stop = result.span()
        segment = p.originalData[start:stop]
        return ParserStatus(
            isFailure=False,
            originalData=p.originalData,
            offset=stop,
            payload={'data': int(segment)},
        )

    return ParserStatus(
        isFailure=True,
        originalData=p.originalData,
        offset=p.offset,
        payload={'error': f'\'{p.originalData}\' is not an integer'},
    )

def string(p: ParserStatus) -> ParserStatus:
    result = re.compile(r'\S+').match(p.originalData, p.offset)
    if result:
        start, stop = result.span()

def letter(l: str):
    if len(l) > 1: raise ValueError(f'\'{l}\' is not a letter')
    def parser(p: ParserStatus) -> ParserStatus:
        result = re.compile(l).match(p.originalData, p.offset)
        if result:
            start, stop = result.span()
            segment = p.originalData[start:stop]
            return ParserStatus(
                isFailure=False,
                originalData=p.originalData,
                offset=stop,
                payload={'data': segment},
            )
        
        return ParserStatus(
            isFailure=True,
            originalData=p.originalData,
            offset=p.offset,
            payload={'error': f'Expected \'{l}\', got \'{p.originalData[p.offset]}\''}
        )
    return parser

def text(t: str):
    def parser(p: ParserStatus) -> ParserStatus:
        result = re.compile(t).match(p.originalData, p.offset)
        if result:
            start, stop = result.span()
            segment = p.originalData[start:stop]
            return ParserStatus(
                isFailure=False,
                originalData=p.originalData,
                offset=stop,
                payload={'data': segment},
            )
        
        return ParserStatus(
            isFailure=True,
            originalData=p.originalData,
            offset=p.offset,
            payload={'error': 'Failed to grab text'}
        )
    return parser

def eof(p: ParserStatus) -> ParserStatus:
    if len(p.originalData) != p.offset:
        return ParserStatus(
            isFailure=True,
            originalData=p.originalData,
            offset=p.offset,
            payload={'error': 'Buffer not empty'}
        )
    return ParserStatus(
        isFailure=False,
        originalData=p.originalData,
        offset=p.offset,
        payload={'data': None}
    )

def seqOf(*parsers):
    def sequence(p: ParserStatus) -> ParserStatus:
        payload = []
        for parser in parsers:
            p = parser(p)
            if p.isFailure: return p
            payload.append(
                p.payload['data']
            )

        return ParserStatus(
            isFailure=False,
            originalData=p.originalData,
            offset=p.offset,
            payload={'data': payload},
        )
    return sequence

def map_parser(function: Callable, parser: ParserFunc):
    def mapParser(p: ParserStatus) -> ParserStatus:
        result = parser(p)

        if result.isFailure: return result
        return ParserStatus(
            isFailure=False,
            originalData=result.originalData,
            offset=result.offset,
            payload={'data': function(result.payload['data'])}
        )

    return mapParser

def oneOf(*parsers: ParserFunc):
    def oneOfParser(p: ParserStatus) -> ParserStatus:
        for parser in parsers:
            result: ParserStatus = parser(p)

            if result.isFailure: continue

            return result
        
        return ParserStatus(
            isFailure=True,
            originalData=p.originalData,
            offset=p.offset,
            payload={'error': 'Couldn\'t find a match'},
        )
    return oneOfParser

def many(parser: ParserFunc):
    def manyParser(p: ParserStatus) -> ParserStatus:
        result = []
        copy = p
        while len(copy.originalData) > copy.offset:
            succesor = parser(copy)
            if succesor.isFailure: break

            result.append(succesor.payload['data'])
            copy = succesor
        
        if result:
            return ParserStatus(
                isFailure=False,
                originalData=p.originalData,
                offset=copy.offset,
                payload={'data': result}
            )
        return succesor
    return manyParser

def sepBy(separator: str):
    sep_parser = text(separator)
    def operator(parser: ParserFunc):
        def sepParser(p: ParserStatus) -> ParserStatus:
            result = []
            copy = p
            while len(copy.originalData) > copy.offset:
                succesor = parser(copy)
                if succesor.isFailure: break
                copy = succesor

                result.append(succesor.payload['data'])

                succesor = sep_parser(succesor)
                if succesor.isFailure: break
                copy = succesor
            
            if result:
                return ParserStatus(
                    isFailure=False,
                    originalData=p.originalData,
                    offset=copy.offset,
                    payload={'data': result}
                )
            return succesor
        return sepParser
    return operator

def between(left: ParserFunc, right: ParserFunc):
    def operator(content: ParserFunc):
        def parser(p: ParserStatus) -> ParserStatus:

            succesor = left(p)
            if succesor.isFailure: return succesor

            succesor = content(succesor)

            r = right(succesor)
            if r.isFailure: return r

            return succesor
        return parser
    return operator

def nested():
    ...


if __name__ == "__main__":
    p = ParserStatus(False, '[12,34,34,aaa,244]', 0, {})
    bracet = between(text(r'\['), text(r'\]'))

    array_element = oneOf(integer, text('aaa'), ...)
    
    array = bracet(sepBy(',')(array_element))

    p = array(p)
    print(p)